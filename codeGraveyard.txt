# ------- code graveyard
#
# def schoepeProcess(regString=r"DLS.*\.txt", samplereg="_", path=os.getcwd(),
#                    fallOffFunction=(lambda x: 0.8*x), channelStart=12):
#     """
#     DOES WAYYYY TOO MUCH; NEEDS TO BE CHANGE.
#     Takes in a path. Creates ALV Objects from the ALV files contained in the
#     path. Reduces Data contained in the samples, start with the value given in
#     channelStart and ending after the initial value has fallen under a certain
#     point specified by the fallOffFunction in dependence of the initial value.
#
#     The log of the correlation function then gets plotted over the delay time
#     (ln (g^2(q,tau) -1) again tau) and fitted in a linear function.
#
#     The intercept that is obtained in the linear function for every ALVObject
#     is then plotted against the scattering angle q.
#
#     Input:
#         samplereg: regular expression that assigns sample name by splitting
#         at the pattern given.
#
#         regString: Regular expression as string, gets compiled to reexp object
#         and passed in into getALVFiles to find files that match the regexp.
#
#         path: string, full path to operating system
#
#         fallOffFunction: function that takes at the starting value (at index
#         channelStart), operates on it and determines the value where the cut-
#         off (last value that is used in the fitting later) value lies.
#
#         channelStart: int, determine the index of the first element that should
#         be taken into consideration at data evaluation.
#
#     Output:
#         Plots of data, relevant coefficients in .txt files.
#     """
#     objList = createALVObjs(regString)
#
#     # deletes fit textfile should it already exist.
#     for ALV in objList:
#         ALV.samplename = re.split(samplereg, ALV.filename)[0]
#
#         path = ALV.createDir()
#         txpath = path + PSEP + ALV.samplename + "Fit.txt"
#         if os.path.isfile(txpath):
#             os.remove(txpath)
#
#     for ALV in objList:
#
#         # konfuse Methode um den Endpunkt herauszufinden
#         end = [k for k in range(channelStart+2, len(ALV.akf)) if ALV.akf[k]
#                < fallOffFunction(ALV.akf[channelStart])][0]
#         datarange = (channelStart, end)
#         print(datarange)
#
#         # Saves images to folders
#         print(ALV)
#         path = ALV.createDir()
#         impath = path + PSEP + ALV.samplename + str(int(ALV.angle)) \
#             + "Grad.png"
#         ALV.saveAKFln(impath, datarange)
#
#         # saves fit parameters to textfile.
#         txpath = path + PSEP + ALV.samplename + "Fit.txt"
#         if not os.path.isfile(txpath):
#             with open(txpath, "w+") as txfile:
#                 txfile.write(
#                      "Angle\t\tq^2\t\t\t\tA\t\tGamma [1/s]\t\tMeanCR0 \t\t\n")
#
#         with open(txpath, "a") as txfile:
#             txfile.write(str(ALV.angle) + "\t\t" + "%.4E" % ALV.q**2 + "\t\t"
#                          + "%.4f" % ALV.A + "\t\t"
#                          + "%.4f" % ALV.gamma + "\t\t"
#                          + "%.4f" % ALV.countrate + "\t\t\n")
#
#     # plottet Gamma gegen q^2, gewinnt daraus Diffusionskoeffizient
#     namediff = None
#     for ALV in objList:
#         if namediff is None or not namediff == ALV.samplename:
#             qList = []
#             gammaList = []
#             aList = []
#             angleList = []
#             countList = []
#             namediff = ALV.samplename
#             txpath = ALV.createDir() + PSEP + ALV.samplename + "Fit.txt"
#             with open(txpath, "r") as txfile:
#                 next(txfile)
#                 for line in txfile:
#                     line = line.split("\t\t")
#                     qList.append(float(line[1]))
#                     gammaList.append(float(line[3]))
#                     angleList.append(float(line[0]))
#                     aList.append(float(line[2]))
#                     countList.append(float(line[4]))
#
#             # Muss aus irgendwelchen Gr체nden ein numpy array sein
#             # plottet gamma, mit von gamma
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             qList = np.array(qList)
#             gammaList = np.array(gammaList)
#             plt.plot(qList, gammaList, ' ko', markersize=2, label="Gamma")
#             popt, pcov = fitlin(qList, gammaList)
#             diffcoff = popt[0]
#             plt.plot(qList, linfun(qList, *popt), '-r',
#                      label="Lin. Gamma Fit, a = " + "%.2E" % diffcoff)
#             plt.legend()
#             plt.xlabel("q^2 [m^-2]")
#             plt.ylabel(r"$\Gamma$ [1/s]")
#             plt.title(ALV.samplename + ", Gamma over q^2")
#             plt.savefig(
#                 ALV.createDir() + PSEP + ALV.samplename + "GammaFit.png")
#             plt.close()
#
#             # plots intercept over angle
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             plt.plot(
#                 angleList, aList, ' bo', markersize=2, label="y-Intercept")
#             plt.legend()
#             plt.title(ALV.samplename + ", y-Intercept over angle")
#             plt.xlabel(r"$\theta$ in 째")
#             plt.ylabel("y-intercept (logarithmical, from fit)")
#             plt.savefig(
#                 ALV.createDir() + PSEP + ALV.samplename + "y-intercept.png")
#             plt.close()
#
#             # plots Mean Countrate over angle
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             plt.plot(angleList, countList, ' bo', markersize=2, label="meanCR")
#             plt.legend()
#             plt.title(ALV.samplename + ", meanCR over angle")
#             plt.xlabel(r"$\theta$ in 째")
#             plt.ylabel("Mean Countrate")
#             plt.savefig(ALV.createDir() + PSEP + ALV.samplename + "meanCR.png")
#             plt.close()
#
#             hydr = getHydroDynR(diffcoff, ALV.visc, ALV.temp)
#
#             with open(txpath, "a") as tx:
#                 tx.write("\nDiffusion coefficient: " + str(diffcoff))
#                 tx.write("\nHydrodynamic Radius [m]: " + str(hydr))
#
#     input("Erfolgreich abgeschlossen."
#           "Enter dr체cken um das Programm zu beenden.")
#     return