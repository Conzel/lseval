# -*- coding: utf-8 -*-
"""
Script for DLS Data processing.

@author: Alex
zuletzt modifiziert: 03.08.2018
"""
# import matplotlib
# matplotlib.use("Agg")

import re
import math
import fitfunctions as ff
from constants import KB


try:
    import numpy as np
except ImportError:
    input("Numpy not installed.")
    exit

try:
    import matplotlib.pyplot as plt
except ImportError:
    input("Matplotlib not installed.")
    exit

try:
    import scipy.optimize as sco
except ImportError:
    input("Scipy not installed.")

try:
    import os
except ImportError:
    input("os module not installed.")

# Adjusts path separator depending on OS.
if os.name == "nt":
    PSEP = "\\"
elif os.name == "posix":
    PSEP = "/"
else:
    print("Operating System not recognized. Exiting.")
    exit()


def isFloat(num):
    """
    Returns True if input is a number, otherwise False.
    """
    try:
        float(num)
        return True
    except (TypeError, ValueError):
        return False


def match(regExp, string):
    """
    returns true if regExp matches string, false otherwise.
    """
    return re.search(regExp, string) is not None

def getConstVal(filename, Name):
    """
    Reads out constants from ALV autogenerated file.

    filename: Name of the file to read angle from.
    Name: The name of the constant the function should look for
    returns: constant value.
    """
    with open(filename, "r") as f:
        for line in f:
            if Name in line:
                lsplit = line.split()
                for el in lsplit:
                    if isFloat(el):
                        return float(el)
    print("Nothing found.")
    return


def getSampleName(filename):
    """
    Reads out samplename from ALV autogenerated file.

    filename: Name of the file to read angle from.
    """
    with open(filename, "r") as f:
        for line in f:
            if "Samplename" in line:
                lsplit = line.split()
                return lsplit[2][1:-1]


def getDynData(filename):
    """
    Reads out delay time, Autocorrelation function and standard deviation

    returns: list of delay times tau, AKF, Measurement Time and Countrate
    """
    flag1 = False
    flag2 = False
    delayL = []
    akfL = []
    measTimeL = []
    countrateL = []

    with open(filename, "r") as f:
        for line in f:
            # findet dynamische Werte, da sie nach "Correlation" auftreten.
            if flag1:
                corrVals = line.split()
                try:
                    if isFloat(corrVals[0]) and isFloat(corrVals[1]):
                        delayL.append(float(corrVals[0]))
                        akfL.append(float(corrVals[1]))
                except IndexError:
                    pass
            if "Correlation" in line:
                flag1 = True

            if flag2:
                timeAndCountrate = line.split()
                try:
                    if isFloat(timeAndCountrate[0]):
                        measTimeL.append(float(timeAndCountrate[0]))
                except IndexError:
                    pass

                try:
                    if isFloat(timeAndCountrate[1]):
                        countrateL.append(float(timeAndCountrate[1]))
                except IndexError:
                    pass
            if "Count Rate" in line:
                flag1 = False
                flag2 = True

    return delayL, akfL, measTimeL, countrateL


class ALVData(object):
    """
    The corresponding data of a single ALV generated file.
    Contains various information gathered by getDynData and getConstVal.

    filename: Name of the file the data is located.
    samplename = Name of the sample.
    angle = Angle in degrees under which the sample was measured.
    refInd = refractive index of the sample.
    delay = Delay time tau of the autocorrelation function (akf)
    akf = Autocorrelation function calculated by ALV software (g2 - 1)
    stdDev = Standard deviation of the autocorrelation function.
    """

    def __init__(self, filename, fitfun):
        dyndata = getDynData(filename)

        self.filename = filename
        self.fitfun = fitfun
        self.samplename = getSampleName(filename)
        self.angle = getConstVal(filename, "Angle")
        self.refInd = getConstVal(filename, "Refractive Index")
        self.wavelength = getConstVal(filename, "Wavelength") * 1e-9
        self.visc = getConstVal(filename, "Viscosity")
        self.temp = getConstVal(filename, "Temperature")
        self.delay = np.array(dyndata[0])
        self.akf = np.array(dyndata[1])
        self.meastime = np.array(dyndata[2])
        self.countrate = np.array(dyndata[3])
        self.coeffs = None
        self.A = None
        self.q = 4*np.pi * self.refInd / self.wavelength * \
            np.sin(np.deg2rad(self.angle/2))
        self.meanCR = getConstVal(filename, "MeanCR0")

    def __str__(self):
        return self.filename

    def __repr__(self):
        return "ALVData("+self.filename+")"

    def curveFit(self):
        """
        Uses fitFun to plot data to single exponential autocorrelation function
        """
        popt, pcov = sco.curve_fit(self.fitfun, self.delay, self.akf)
        self.coeffs = popt[:]
        return popt, pcov

    def saveAKF(self, filepath, start=0, fallOff=-math.inf):
        """
        Saves Plot of the autocorrelation function versus the delay time tau
        in a file, fitted in a single exponential. A dynamic datarange can
        be specified using the start and fallOff parameters.

        filepath: Path of the file where the plot should be saved to.
        datarange: Range of how many data points in the array should be used.
        start: Only uses point in the array after this value.
        fallOff: Slices array after start-value/current-value is lower than the
        fallOff.
        """
        # schneidet Delay und Autokorrelation nach den Vorgaben der datarange
        startValue = self.akf[start]
        akf = []

        for el in self.akf:
            if startValue/el > fallOff:
                akf.append(el)
            else:
                break

        delay = self.delay[start:len(akf)]

        plt.semilogx(delay)
        plt.figure(self.filename, dpi=100)
        plt.clf()
        plt.semilogx(delay, akf, " bo", markersize=2,
                     label="Autocorrelation data")
        popt, pcov = self.curveFit()
        plt.semilogx(delay, self.fitfun(delay, *popt), '-r',
                     label="%s fit" % ff.nameOf(self.fitfun))
        plt.legend()
        plt.xlabel(r"Delay Time " + chr(964) + " [ms]")
        plt.ylabel("Autocorrelation Function g2 - 1")
        plt.title(self.samplename + ", Angle " + str(self.angle) + "°")

        plt.savefig(filepath)
        plt.close()
        return

    # def saveAKFln(self, filepath, datarange=0):
    #     """
    #     Saves Plot of the autocorrelation function versus the delay time tau
    #     in a file, fitted in a single exponential.
    #
    #     filepath: Path of the file where the plot should be saved to.
    #     """
    #     # Verwendet volle Range der Daten, wenn datarange nicht
    #     # spezifiziert wurde.
    #     if datarange == 0:
    #         datarange = [0, len(self.akf) - 1]
    #
    #     # schneidet Delay und Autokorrelation nach den Vorgaben der Datarange
    #     delay = self.delay[datarange[0]:datarange[1]]
    #     akf = self.akf[datarange[0]:datarange[1]]
    #     akfLog = [math.log(el) if el > 0 else 0 for el in akf]
    #
    #     plt.semilogx(delay)
    #     plt.figure(self.filename, dpi=100)
    #     plt.clf()
    #     plt.plot(delay, akfLog, " bo", markersize=2,
    #              label="Autocorrelation data, logarithmic")
    #
    #     popt, pcov = sco.curve_fit(self.fitfun, delay, akf)
    #     plt.plot(delay,
    #              [math.log(el) if el > 0 else 0
    #               for el in self.fitfun(delay, *popt)],
    #              '-r', label="%s fit" % ff.nameOf(self.fitfun))
    #     plt.legend()
    #     plt.xlabel(r"Delay Time " + chr(964) + " [ms]")
    #     plt.ylabel("Autocorrelation Function log(g2 - 1)")
    #     plt.title(self.samplename + ", Angle " + str(self.angle) + "°")
    #
    #     plt.savefig(filepath)
    #     plt.close()
    #     return

    def createDir(self):
        """
        Creates a directory for the current unique sample, if the directory
        doesnt already exist.

        returns: path of the directory
        """
        # Strips the samplename with .txt ending off the filename, attaches the
        # samplename back again.
        targetPath = re.sub(self.samplename+r"(\d+)\.(\w)+$",
                            self.samplename, self.filename)

        if not os.path.exists(targetPath):
            os.makedirs(targetPath)
            return targetPath
        else:
            return targetPath


def getFilesInFolder(path=os.getcwd(), searchReg="_averaged.ASC"):
    """
    Returns a list of all filenames from the folder specified in path
    with the searchString as regular expression.
    """
    fileList = os.listdir(path)
    filteredList = []
    for name in fileList:
        if re.match(searchReg, name):
            filteredList.append(name)
    return filteredList


def getHydroDynR(diffu, visc, temp):
    """
    Calculates hydrodynamic radius from inputs, all in SI units.

    diff: Diffusion coefficient
    visc: dynamic viscosity of solvent
    temp: Temperature of surroundings.
    """
    rhyd = KB * temp / (6 * np.pi * visc * diffu)
    return rhyd


# def fajunProcess():
#     """
#     Takes list of ALV objects, saves their autocorrelation figures + plot in
#     the corresponding directory. Saves fitting parameters in a .txt file.
#     """
#
#     objList = createALVObjs()
#
#     input("Enter drücken um fortzufahren.")
#     print("Lade Dateien...")
#
#     # deletes fit textfile should it already exist.
#     for ALV in objList:
#         path = ALV.createDir()
#         txpath = path + PSEP + ALV.samplename + "Fit.txt"
#         if os.path.isfile(txpath):
#             os.remove(txpath)
#
#     for ALV in objList:
#         # Saves images to folders
#         print(ALV)
#         path = ALV.createDir()
#         impath = path + PSEP + ALV.samplename + str(int(ALV.angle))\
#             + "Grad.png"
#         ALV.saveAKF(impath)
#
#         # saves fit parameters to textfile.
#         txpath = path + PSEP + ALV.samplename + "Fit.txt"
#         if not os.path.isfile(txpath):
#             with open(txpath, "w+") as txfile:
#                 txfile.write("Angle\t\tq^2\t\t\tA\t\tGamma [1/s]\t\t\n")
#
#         with open(txpath, "a") as txfile:
#             txfile.write(str(ALV.angle) + "\t\t" + "%.4E" % ALV.q**2 + "\t\t"
#                          + "%.4f" % ALV.A + "\t\t"
#                          + "%.4f" % ALV.gamma + "\t\t\n")
#
#     # plottet Gamma gegen q^2, gewinnt daraus Diffusionskoeffizient
#     namediff = None
#     for ALV in objList:
#         if namediff is None or not namediff == ALV.samplename:
#             qList = []
#             gammaList = []
#             namediff = ALV.samplename
#             txpath = ALV.createDir() + PSEP + ALV.samplename + "Fit.txt"
#             with open(txpath, "r") as txfile:
#                 next(txfile)
#                 for line in txfile:
#                     line = line.split("\t\t")
#                     qList.append(float(line[1]))
#                     gammaList.append(float(line[3]))
#
#             # Muss aus irgendwelchen Gründen ein numpy array sein
#             # plottet
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             qList = np.array(qList)
#             gammaList = np.array(gammaList)
#             plt.plot(qList, gammaList, ' ko', markersize=2, label="Gamma")
#             popt, pcov = fitlin(qList, gammaList)
#             diffcoff = popt[0]
#             plt.plot(qList, linfun(qList, *popt), '-r',
#                      label="Lin. Gamma Fit, a = " + "%.2E" % diffcoff)
#             plt.legend()
#             plt.xlabel("q^2 [m^-2]")
#             plt.ylabel(r"$\Gamma$ [1/s]")
#             plt.title(ALV.samplename + ", Gamma over q^2")
#             plt.savefig(ALV.createDir() + PSEP + ALV.samplename
#                         + "GammaFit.png")
#             plt.close()
#
#             hydr = getHydroDynR(diffcoff, ALV.visc, ALV.temp)
#
#             with open(txpath, "a") as tx:
#                 tx.write("\nDiffusion coefficient: " + str(diffcoff))
#                 tx.write("\nHydrodynamic Radius [m]: " + str(hydr))
#
#     input("Erfolgreich abgeschlossen."
#           "Enter drücken um das Programm zu beenden.")
#     return

def readElementsAndProcessDLS(filenames, fitfun, start=0, fallOff=0, log=False,
                              saveImg=True):
    """
    Simply combines basic execution of ALV Elements functions. Can take any
    amount of filenames in an array.

    The possibility in saveAKF to give out a data range can be leveraged using
    the start and fallOff parameters as indicated in the saveAKF function.

    filenames: list of filenames that correspond to ALV Data, alternatively a
    single string that will be converted into a list. If the path to a direc-
    tory is given, the files inside the directory will be used as a file list.
    fitfun: fitfunction, can be supplied using the fitfunction.py
    start: array value at which fitting begins.
    fallOff: quotient at which fitting stops.
    log: Set to true if coefficients, countrate, angle and further stats should
         be logged.
    saveImg: Set to true if the fitfunctions should be plotted together with
             the data in a separate folder.

    returns dictionary of data about the whole sample for further processing.
    """
    # enables the function to also accept a single string as input, which
    # can be a directory.

    if type(filenames) is str:
        if os.path.isdir(filenames):
            contents = os.listdir(filenames)
            getFilesInFolder(filenames, r"\d+\.\w+$")
            filenames = [os.getcwd() + PSEP + filenames + PSEP
                         + name for name in contents]
            print(filenames)
        else:
            filenames = [filenames]

    if len(filenames) == 0:
        print("Empty List passed into function")
        return

    dataDict = {}
    meanCRs = []
    coefficients = []
    angles = []

    for data in filenames:

        # prepares data to be returned in dictionary later
        el = ALVData(data, fitfun)
        el.curveFit()
        meanCRs.append(el.meanCR)
        coefficients.append(el.coeffs)
        angles.append(el.angle)
        savingPath = el.createDir()

        if saveImg:
            impath = savingPath + PSEP + el.samplename + str(int(el.angle)) \
                + "Grad.png"
            el.saveAKF(impath)

        if log:
            txpath = savingPath + PSEP + el.samplename + "Fit.txt"
            if not os.path.isfile(txpath):
                with open(txpath, "w+") as txfile:
                    txfile.write(
                         "Angle\t\tq^2\t\t\t\tMeanCR0 \t\tFit Coeffs\n")

            print(el.coeffs)
            coeffForm = list(map(lambda x: "%.4f" % x, el.coeffs))
            coeffStr = ""
            for coeff in coeffForm:
                coeffStr += coeff + "\t\t"

            with open(txpath, "a") as txfile:
                txfile.write(str(el.angle) + "\t\t" + "%.4E" % el.q**2 + "\t\t"
                             + "%.4f" % el.meanCR + "\t\t\t" + coeffStr + "\n")

    dataDict["meanCRs"] = meanCRs
    dataDict["coeffs"] = coefficients
    dataDict["path"] = savingPath
    dataDict["angles"] = angles
    dataDict["samplename"] = el.samplename

    return dataDict

# TODO:
#     Idee für rekursive Implementation:
#         Da createDir nun mit absoluten Pfaden arbeitet, kann die
#         Grundlage für eine rekursive Implementation geschaffen werden:
#         Ein Ordner (oder filenames) werden an den rekursiven Überprozess
#         gegeben.
#         Files werden an readElementsAndProcessDLS als Liste mit geupdatetem
#         Pfad weitergereicht (Ordnerpfad + Name der File). Ordner werden als
#         Argument verwendet, um den rekursiven Prozess erneut zu spawnen.


def recursiveCall(function, filter, folder=os.getcwd()):
    """
    Calls the function specified recursively on a folder. Opens folder,
    every file found on the level of the folder, that fits the filter (regExp)
    gets passed as a list to the function. Every folder found gets used
    to call recursiveCall again.

    function: function of one argument, gets called with a list of the found
    files on everylevel.
    folder: starting folder, gets opened first.
    filter: function of one input which takes in a filename and returns True
    if the file should be passed on to function, False otherwise
    """

    # we are better off working only with absolute paths from now on. This is
    # just a safety measure essentially, this function does not change an
    # already absolute path at all.
    abspath = os.path.abspath(folder)
    folderContents = os.listdir(abspath)

    files = []
    folders = []
    if len(folderContents) != 0:
        for entry in folderContents:
            if os.path.isdir(entry):
                folders.append(entry)
            elif filter(entry):
                files.append(entry)

        # makes the contents list a list containing full paths.
        files = [abspath + PSEP + path for path in files]
        if len(files) > 0:
            function(files)

        folders = [abspath + PSEP + path for path in folders]
        if len(folders) > 0:
            for newFolder in folders:
                print(newFolder)
                recursiveCall(function, filter, newFolder)
    return


recursiveCall(lambda x: readElementsAndProcessDLS(x, ff.cum3, 8, 0.8),
              lambda y: match(r"^DLS_", y))

def plotMeanCRsDLS(filenames):
    """
    Plots mean countrate over angle, extracted from the given filenames.
    """
    # fit function not relevant for countrate, we just take the simplest one
    dataDict = readElementsAndProcessDLS(filenames, ff.singleExp)

    plt.figure(dataDict["samplename"], dpi=100)
    plt.clf()
    plt.semilogy(dataDict["angles"], dataDict["meanCRs"], ' bo', markersize=2,
             label="meanCR")
    plt.legend()
    plt.title(dataDict["samplename"] + ", meanCR over angle")
    plt.xlabel(r"$\theta$ in °")
    plt.ylabel("Mean Countrate")
    plt.savefig(dataDict["path"] + PSEP
                + dataDict["samplename"] + "meanCR.png")
    plt.close()
    return

#------ testing
# reg = r"^.*\.txt$"
# files = os.listdir(os.getcwd())
# files = [f for f in files if re.match(reg, f) is not None]
# readElementsAndProcessDLS(files, ff.cum3, start=8, fallOff=0.8, log=True)
# plotMeanCRsDLS(files)

#
# sampleName = "DLS_Test_75nmDoppellinse"
#
# readElementsAndProcessDLS(sampleName, ff.cum3, start=10, fallOff=0.8, log=True)


# ------- code graveyard
#
# def schoepeProcess(regString=r"DLS.*\.txt", samplereg="_", path=os.getcwd(),
#                    fallOffFunction=(lambda x: 0.8*x), channelStart=12):
#     """
#     DOES WAYYYY TOO MUCH; NEEDS TO BE CHANGE.
#     Takes in a path. Creates ALV Objects from the ALV files contained in the
#     path. Reduces Data contained in the samples, start with the value given in
#     channelStart and ending after the initial value has fallen under a certain
#     point specified by the fallOffFunction in dependence of the initial value.
#
#     The log of the correlation function then gets plotted over the delay time
#     (ln (g^2(q,tau) -1) again tau) and fitted in a linear function.
#
#     The intercept that is obtained in the linear function for every ALVObject
#     is then plotted against the scattering angle q.
#
#     Input:
#         samplereg: regular expression that assigns sample name by splitting
#         at the pattern given.
#
#         regString: Regular expression as string, gets compiled to reexp object
#         and passed in into getALVFiles to find files that match the regexp.
#
#         path: string, full path to operating system
#
#         fallOffFunction: function that takes at the starting value (at index
#         channelStart), operates on it and determines the value where the cut-
#         off (last value that is used in the fitting later) value lies.
#
#         channelStart: int, determine the index of the first element that should
#         be taken into consideration at data evaluation.
#
#     Output:
#         Plots of data, relevant coefficients in .txt files.
#     """
#     objList = createALVObjs(regString)
#
#     # deletes fit textfile should it already exist.
#     for ALV in objList:
#         ALV.samplename = re.split(samplereg, ALV.filename)[0]
#
#         path = ALV.createDir()
#         txpath = path + PSEP + ALV.samplename + "Fit.txt"
#         if os.path.isfile(txpath):
#             os.remove(txpath)
#
#     for ALV in objList:
#
#         # konfuse Methode um den Endpunkt herauszufinden
#         end = [k for k in range(channelStart+2, len(ALV.akf)) if ALV.akf[k]
#                < fallOffFunction(ALV.akf[channelStart])][0]
#         datarange = (channelStart, end)
#         print(datarange)
#
#         # Saves images to folders
#         print(ALV)
#         path = ALV.createDir()
#         impath = path + PSEP + ALV.samplename + str(int(ALV.angle)) \
#             + "Grad.png"
#         ALV.saveAKFln(impath, datarange)
#
#         # saves fit parameters to textfile.
#         txpath = path + PSEP + ALV.samplename + "Fit.txt"
#         if not os.path.isfile(txpath):
#             with open(txpath, "w+") as txfile:
#                 txfile.write(
#                      "Angle\t\tq^2\t\t\t\tA\t\tGamma [1/s]\t\tMeanCR0 \t\t\n")
#
#         with open(txpath, "a") as txfile:
#             txfile.write(str(ALV.angle) + "\t\t" + "%.4E" % ALV.q**2 + "\t\t"
#                          + "%.4f" % ALV.A + "\t\t"
#                          + "%.4f" % ALV.gamma + "\t\t"
#                          + "%.4f" % ALV.countrate + "\t\t\n")
#
#     # plottet Gamma gegen q^2, gewinnt daraus Diffusionskoeffizient
#     namediff = None
#     for ALV in objList:
#         if namediff is None or not namediff == ALV.samplename:
#             qList = []
#             gammaList = []
#             aList = []
#             angleList = []
#             countList = []
#             namediff = ALV.samplename
#             txpath = ALV.createDir() + PSEP + ALV.samplename + "Fit.txt"
#             with open(txpath, "r") as txfile:
#                 next(txfile)
#                 for line in txfile:
#                     line = line.split("\t\t")
#                     qList.append(float(line[1]))
#                     gammaList.append(float(line[3]))
#                     angleList.append(float(line[0]))
#                     aList.append(float(line[2]))
#                     countList.append(float(line[4]))
#
#             # Muss aus irgendwelchen Gründen ein numpy array sein
#             # plottet gamma, mit von gamma
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             qList = np.array(qList)
#             gammaList = np.array(gammaList)
#             plt.plot(qList, gammaList, ' ko', markersize=2, label="Gamma")
#             popt, pcov = fitlin(qList, gammaList)
#             diffcoff = popt[0]
#             plt.plot(qList, linfun(qList, *popt), '-r',
#                      label="Lin. Gamma Fit, a = " + "%.2E" % diffcoff)
#             plt.legend()
#             plt.xlabel("q^2 [m^-2]")
#             plt.ylabel(r"$\Gamma$ [1/s]")
#             plt.title(ALV.samplename + ", Gamma over q^2")
#             plt.savefig(
#                 ALV.createDir() + PSEP + ALV.samplename + "GammaFit.png")
#             plt.close()
#
#             # plots intercept over angle
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             plt.plot(
#                 angleList, aList, ' bo', markersize=2, label="y-Intercept")
#             plt.legend()
#             plt.title(ALV.samplename + ", y-Intercept over angle")
#             plt.xlabel(r"$\theta$ in °")
#             plt.ylabel("y-intercept (logarithmical, from fit)")
#             plt.savefig(
#                 ALV.createDir() + PSEP + ALV.samplename + "y-intercept.png")
#             plt.close()
#
#             # plots Mean Countrate over angle
#             plt.figure(ALV.samplename, dpi=100)
#             plt.clf()
#             plt.plot(angleList, countList, ' bo', markersize=2, label="meanCR")
#             plt.legend()
#             plt.title(ALV.samplename + ", meanCR over angle")
#             plt.xlabel(r"$\theta$ in °")
#             plt.ylabel("Mean Countrate")
#             plt.savefig(ALV.createDir() + PSEP + ALV.samplename + "meanCR.png")
#             plt.close()
#
#             hydr = getHydroDynR(diffcoff, ALV.visc, ALV.temp)
#
#             with open(txpath, "a") as tx:
#                 tx.write("\nDiffusion coefficient: " + str(diffcoff))
#                 tx.write("\nHydrodynamic Radius [m]: " + str(hydr))
#
#     input("Erfolgreich abgeschlossen."
#           "Enter drücken um das Programm zu beenden.")
#     return
