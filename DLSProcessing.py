# -*- coding: utf-8 -*-
"""
Script for DLS Data processing.

@author: Alex
zuletzt modifiziert: 03.08.2018
"""
# import matplotlib
# matplotlib.use("Agg")

import re
import math
import fitfunctions as ff
from constants import KB
import utils as ut


try:
    import numpy as np
except ImportError:
    input("Numpy not installed.")
    exit

try:
    import matplotlib.pyplot as plt
except ImportError:
    input("Matplotlib not installed.")
    exit

try:
    import scipy.optimize as sco
except ImportError:
    input("Scipy not installed.")

try:
    import os
except ImportError:
    input("os module not installed.")

# Adjusts path separator depending on OS.
if os.name == "nt":
    PSEP = "\\"
elif os.name == "posix":
    PSEP = "/"
else:
    print("Operating System not recognized. Exiting.")
    exit()


def getConstVal(filename, Name):
    """
    Reads out constants from ALV autogenerated file.

    filename: Name of the file to read angle from.
    Name: The name of the constant the function should look for
    returns: constant value.
    """
    with open(filename, "r") as f:
        for line in f:
            if Name in line:
                lsplit = line.split()
                for el in lsplit:
                    if ut.isFloat(el):
                        return float(el)
    print("Nothing found.")
    return


def getSampleName(filename):
    """
    Reads out samplename from ALV autogenerated file.

    filename: Name of the file to read angle from.
    """
    with open(filename, "r") as f:
        for line in f:
            if "Samplename" in line:
                lsplit = line.split()
                return lsplit[2][1:-1]


def getDynData(filename):
    """
    Reads out delay time, Autocorrelation function and standard deviation

    returns: list of delay times tau, AKF, Measurement Time and Countrate
    """
    flag1 = False
    flag2 = False
    delayL = []
    akfL = []
    measTimeL = []
    countrateL = []

    with open(filename, "r") as f:
        for line in f:
            # findet dynamische Werte, da sie nach "Correlation" auftreten.
            if flag1:
                corrVals = line.split()
                try:
                    if ut.isFloat(corrVals[0]) and ut.isFloat(corrVals[1]):
                        delayL.append(float(corrVals[0]))
                        akfL.append(float(corrVals[1]))
                except IndexError:
                    pass
            if "Correlation" in line:
                flag1 = True

            if flag2:
                timeAndCountrate = line.split()
                try:
                    if ut.isFloat(timeAndCountrate[0]):
                        measTimeL.append(float(timeAndCountrate[0]))
                except IndexError:
                    pass

                try:
                    if ut.isFloat(timeAndCountrate[1]):
                        countrateL.append(float(timeAndCountrate[1]))
                except IndexError:
                    pass
            if "Count Rate" in line:
                flag1 = False
                flag2 = True

    return delayL, akfL, measTimeL, countrateL


class ALVData(object):
    """
    The corresponding data of a single ALV generated file.
    Contains various information gathered by getDynData and getConstVal.

    filename: Name of the file the data is located.
    samplename = Name of the sample.
    angle = Angle in degrees under which the sample was measured.
    refInd = refractive index of the sample.
    delay = Delay time tau of the autocorrelation function (akf)
    akf = Autocorrelation function calculated by ALV software (g2 - 1)
    stdDev = Standard deviation of the autocorrelation function.
    """

    def __init__(self, filename, fitfun):
        dyndata = getDynData(filename)

        self.filename = filename
        self.fitfun = fitfun
        self.samplename = getSampleName(filename)
        self.angle = getConstVal(filename, "Angle")
        self.refInd = getConstVal(filename, "Refractive Index")
        self.wavelength = getConstVal(filename, "Wavelength") * 1e-9
        self.visc = getConstVal(filename, "Viscosity")
        self.temp = getConstVal(filename, "Temperature")
        self.delay = np.array(dyndata[0])
        self.akf = np.array(dyndata[1])
        self.meastime = np.array(dyndata[2])
        self.countrate = np.array(dyndata[3])
        self.coeffs = None
        self.A = None
        self.q = 4*np.pi * self.refInd / self.wavelength * \
            np.sin(np.deg2rad(self.angle/2))
        self.meanCR = getConstVal(filename, "MeanCR0")

    def __str__(self):
        return self.filename

    def __repr__(self):
        return "ALVData("+self.filename+")"

    def curveFit(self):
        """
        Uses fitFun to plot data to single exponential autocorrelation function
        """
        popt, pcov = sco.curve_fit(self.fitfun, self.delay, self.akf)
        self.coeffs = popt[:]
        return popt, pcov

    def saveAKF(self, filepath, start=0, fallOff=-math.inf):
        """
        Saves Plot of the autocorrelation function versus the delay time tau
        in a file, fitted in a single exponential. A dynamic datarange can
        be specified using the start and fallOff parameters.

        filepath: Path of the file where the plot should be saved to.
        datarange: Range of how many data points in the array should be used.
        start: Only uses point in the array after this value.
        fallOff: Slices array after start-value/current-value is lower than the
        fallOff.
        """
        # schneidet Delay und Autokorrelation nach den Vorgaben der datarange
        startValue = self.akf[start]
        akf = []

        for el in self.akf:
            if startValue/el > fallOff:
                akf.append(el)
            else:
                break

        delay = self.delay[start:len(akf)]

        plt.semilogx(delay)
        plt.figure(self.filename, dpi=100)
        plt.clf()
        plt.semilogx(delay, akf, " bo", markersize=2,
                     label="Autocorrelation data")
        popt, pcov = self.curveFit()
        plt.semilogx(delay, self.fitfun(delay, *popt), '-r',
                     label="%s fit" % ff.nameOf(self.fitfun))
        plt.legend()
        plt.xlabel(r"Delay Time " + chr(964) + " [ms]")
        plt.ylabel("Autocorrelation Function g2 - 1")
        plt.title(self.samplename + ", Angle " + str(self.angle) + "째")

        plt.savefig(filepath)
        plt.close()
        return

    def createDir(self):
        """
        Creates a directory for the current unique sample, if the directory
        doesnt already exist.

        returns: path of the directory
        """
        # Strips the samplename with .txt ending off the filename, attaches the
        # samplename back again.
        targetPath = re.sub(self.samplename+r"(\d+)\.(\w)+$",
                            self.samplename, self.filename)

        if not os.path.exists(targetPath):
            os.makedirs(targetPath)
            return targetPath
        else:
            return targetPath


def readElementsAndProcessDLS(filenames, fitfun, start=0, fallOff=0, log=False,
                              saveImg=True):
    """
    Simply combines basic execution of ALV Elements functions. Can take any
    amount of filenames in an array.

    The possibility in saveAKF to give out a data range can be leveraged using
    the start and fallOff parameters as indicated in the saveAKF function.

    filenames: list of filenames that correspond to ALV Data, alternatively a
    single string that will be converted into a list. If the path to a direc-
    tory is given, the files inside the directory will be used as a file list.
    fitfun: fitfunction, can be supplied using the fitfunction.py
    start: array value at which fitting begins.
    fallOff: quotient at which fitting stops.
    log: Set to true if coefficients, countrate, angle and further stats should
         be logged.
    saveImg: Set to true if the fitfunctions should be plotted together with
             the data in a separate folder.

    returns dictionary of data about the whole sample for further processing.
    """
    # enables the function to also accept a single string as input, which
    # can be a directory.

    if type(filenames) is str:
        if os.path.isdir(filenames):
            contents = os.listdir(filenames)
            ut.getFilesInFolder(filenames, r"\d+\.\w+$")
            filenames = [os.getcwd() + PSEP + filenames + PSEP
                         + name for name in contents]
            print(filenames)
        else:
            filenames = [filenames]

    if len(filenames) == 0:
        print("Empty List passed into function")
        return

    dataDict = {}
    meanCRs = []
    coefficients = []
    angles = []
    savingPath = []

    # reciproke scattering vector
    qSquareds = []

    # indicates the return statement that at least one valid file was found
    # (or none).
    oneFileFoundFlag = False

    for data in filenames:

        # prepares data to be returned in dictionary later
        try:
            el = ALVData(data, fitfun)
        except:
            print("Could not open " + data + ".")
            continue

        oneFileFoundFlag = True
        el.curveFit()
        meanCRs.append(el.meanCR)
        coefficients.append(el.coeffs)
        angles.append(el.angle)
        qSquareds.append((el.q)**2)
        savingPath = el.createDir()
        dataDict["samplename"] = el.samplename
        dataDict["visc"] = el.visc
        dataDict["temp"] = el.temp

        if saveImg:
            impath = savingPath + PSEP + el.samplename + str(int(el.angle)) \
                + "Grad.png"
            el.saveAKF(impath)

        if log:
            txpath = savingPath + PSEP + el.samplename + "Fit.txt"
            if not os.path.isfile(txpath):
                with open(txpath, "w+") as txfile:
                    txfile.write(
                         "Angle\t\tq^2\t\t\t\tMeanCR0 \t\tFit Coeffs\n")

            print(el.coeffs)
            coeffForm = list(map(lambda x: "%.4f" % x, el.coeffs))
            coeffStr = ""
            for coeff in coeffForm:
                coeffStr += coeff + "\t\t"

            with open(txpath, "a") as txfile:
                txfile.write(str(el.angle) + "\t\t" + "%.4E" % el.q**2 + "\t\t"
                             + "%.4f" % el.meanCR + "\t\t\t" + coeffStr + "\n")

    if not oneFileFoundFlag:
        return None

    dataDict["meanCRs"] = meanCRs
    dataDict["coeffs"] = coefficients
    dataDict["path"] = savingPath
    dataDict["angles"] = angles
    dataDict["fitfun"] = fitfun
    dataDict["qSqu"] = np.array(qSquareds)

    return dataDict


def plotMeanCRsDLS(dataDict):
    """
    Plots mean countrate over angle, extracted from the given filenames.
    """

    plt.figure(dataDict["samplename"], dpi=100)
    plt.clf()
    plt.plot(dataDict["angles"], dataDict["meanCRs"], ' bo', markersize=2,
             label="meanCR")
    plt.legend()
    plt.title(dataDict["samplename"] + ", meanCR over angle")
    plt.xlabel(r"$\theta$ in 째")
    plt.ylabel("Mean Countrate")
    plt.savefig(dataDict["path"] + PSEP
                + dataDict["samplename"] + "meanCR.png")
    plt.close()
    return


def plotCoherenceFactor(dataDict):
    """
    Plots Coherence Factor (first coefficient in fit function) over q^2.

    Works for fitfunctions cum2, cum3, singleExp.
    """
    # fit function not relevant for countrate, we just take the simplest one

    coherenceFactor = [coeff[0] for coeff in dataDict["coeffs"]]

    plt.figure(dataDict["samplename"], dpi=100)
    plt.clf()
    plt.plot(dataDict["angles"], coherenceFactor, ' bo', markersize=2,
             label="meanCR")
    plt.legend()
    plt.title(dataDict["samplename"] + ", Coherence Factor over angle")
    plt.xlabel(r"$\theta$ in 째")
    plt.ylabel("Coherence Factor")
    plt.savefig(dataDict["path"] + PSEP
                + dataDict["samplename"] + "CF.png")
    plt.close()
    return


def plotGammaAndFit(dataDict):
    """
    Plots gamma over q^2 (first coefficient in fit function) over q^2.

    Works for fitfunctions cum2, cum3, singleExp.
    """
    gamma = [coeff[1] for coeff in dataDict["coeffs"]]
    qSqu = dataDict["qSqu"]

    def linfun(x, a): return a*x

    popt, pcov = sco.curve_fit(linfun, qSqu, gamma)

    plt.figure(dataDict["samplename"], dpi=100)
    plt.clf()
    plt.plot(qSqu, gamma, ' bo', markersize=2, label="meanCR")

    plt.plot(qSqu, linfun(qSqu, *popt), 'r', label="Linear fit")
    plt.legend()
    plt.title(dataDict["samplename"] + ", Gamma over q^2")
    plt.xlabel(r"q^2 in 1/m^2")
    plt.ylabel("Gamma")
    plt.savefig(dataDict["path"] + PSEP
                + dataDict["samplename"] + "Gamma.png")
    plt.close()

    hydrodynR = ut.getHydroDynR(popt[0], dataDict["visc"], dataDict["temp"])
    return hydrodynR


def compareCRs(dataDict1, dataDict2):
    """
    Compares two mean countrates (diving 1 by 2 (1/2)) and plots them.
    """
    CRs1 = dataDict1["meanCRs"]
    CRs2 = dataDict2["meanCRs"]
    divCR = []
    for i in range(len(CRs1)):
        divCR.append(CRs1[i]/CRs2[i])

    plt.figure(dataDict1["samplename"], dpi=100)
    plt.clf()
    plt.plot(dataDict1["angles"], divCR, ' bo', markersize=2,
             label="Mean CR divided")

    plt.legend()
    plt.title(dataDict1["samplename"] + "divided by" + dataDict2["samplename"])
    plt.xlabel(r"Angle in 째")
    plt.ylabel("Countrate")
    plt.savefig(dataDict1["path"] + PSEP
                + dataDict1["samplename"] + "dividedCR.png")
    plt.close()
    return



# reg = r"[0-6]\.txt$"
files = os.listdir(os.getcwd())
# files = [f for f in files if re.match(reg, f) is not None]
dict = readElementsAndProcessDLS(files, ff.cum3b, start=8, fallOff=0.8, log=True)



print("Hydrodynamic Radius:", plotGammaAndFit(dict))
input("")

#
# sampleName = "DLS_Test_75nmDoppellinse"
#
# readElementsAndProcessDLS(sampleName, ff.cum3, start=10, fallOff=0.8, log=True)
