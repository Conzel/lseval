# -*- coding: utf-8 -*-
"""
Script for DLS Data processing.

@author: Alex
zuletzt modifiziert: 28.04.2018
"""
# import matplotlib
# matplotlib.use("Agg")

import re
import math

print("Programm zur ALV-Daten Aufbereitung."
      "Nähere Infos zur Benutzung in der ReadMe.")

try:
    import numpy as np
except ImportError:
    input("Numpy not installed.")
    exit

try:
    import matplotlib.pyplot as plt
except ImportError:
    input("Matplotlib not installed.")
    exit

try:
    import scipy.optimize as sco
except ImportError:
    input("Scipy not installed.")

try:
    import os
except ImportError:
    input("os module not installed.")


KB = 1.38065e-23


def isFloat(num):
    """
    Returns True if input is a number, otherwise False.
    """
    try:
        float(num)
        return True
    except:
        return False


def getConstVal(filename, Name):
    """
    Reads out constants from ALV autogenerated file.

    filename: Name of the file to read angle from.
    Name: The name of the constant the function should look for
    returns: Angle in Degrees.
    """
    with open(filename, "r") as f:
        for line in f:
            if Name in line:
                lsplit = line.split()
                for el in lsplit:
                    if isFloat(el):
                        return float(el)
    print("Nothing found.")
    return


def getDynData(filename):
    """
    Reads out delay time, Autocorrelation function and standard deviation

    returns: list of delay times tau, AKF and std. dev
    """
    flag1 = False
    flag2 = False
    delayL = []
    akfL = []
    stdDevL = []

    with open(filename, "r") as f:
        for line in f:
            # findet dynamische Werte, da sie nach "Correlation" auftreten.
            if flag1:
                corrVals = line.split()
                try:
                    if isFloat(corrVals[0]) and isFloat(corrVals[1]):
                        delayL.append(float(corrVals[0]))
                        akfL.append(float(corrVals[1]))
                except IndexError:
                    pass
            if "Correlation" in line:
                flag1 = True

            if flag2:
                stdval = line.split()
                try:
                    if isFloat(stdval[1]):
                        stdDevL.append(float(stdval[1]))
                except IndexError:
                    pass
            if "Count Rate" in line:
                flag1 = False
                flag2 = True

    return delayL, akfL, stdDevL


class ALVData(object):
    """
    The corresponding data of a single ALV generated file.
    Contains various information gathered by getDynData and getConstVal.

    filename: Name of the file the data is located.
    samplename = Name of the sample.
    angle = Angle in degrees under which the sample was measured.
    refInd = refractive index of the sample.
    delay = Delay time tau of the autocorrelation function (akf)
    akf = Autocorrelation function calculated by ALV software (g2 - 1)
    stdDev = Standard deviation of the autocorrelation function.
    """

    def __init__(self, filename):
        dyndata = getDynData(filename)

        self.filename = filename
        self.samplename = filename.split("_averaged")[0][:-4]
        self.angle = getConstVal(filename, "Angle")
        self.refInd = getConstVal(filename, "Refractive Index")
        self.wavelength = getConstVal(filename, "Wavelength") * 1e-9
        self.visc = getConstVal(filename, "Viscosity")
        self.temp = getConstVal(filename, "Temperature")
        self.delay = np.array(dyndata[0])
        self.akf = np.array(dyndata[1])
        self.stdDev = np.array(dyndata[2])
        self.gamma = None
        self.A = None
        self.q = 4*np.pi * self.refInd / self.wavelength * \
            np.sin(np.deg2rad(self.angle/2))
        self.countrate = getConstVal(filename, "MeanCR0")

    def __str__(self):
        return self.filename

    def __repr__(self):
        return "ALVData("+self.filename+")"

    def fitfun(self, x, a, b):
        """
        Fit function for single exponential autocorrelation function.

        Assumes ergodic samples, for which the siegert relation is valid:
            g2 = 1 + g1^2
            g2 - 1 = a * e^-2*Gamma*tau (g2 - 1 = akf)
        and
            Gamma = Ds*q^2
        """
        return a * np.exp(-2*b*x)

    def curveFit(self):
        """
        Uses fitFun to plot data to single exponential autocorrelation function
        """
        popt, pcov = sco.curve_fit(self.fitfun, self.delay, self.akf)
        return popt, pcov

    def saveAKF(self, filepath):
        """
        Saves Plot of the autocorrelation function versus the delay time tau
        in a file, fitted in a single exponential.

        filepath: Path of the file where the plot should be saved to.
        """
        plt.figure(self.filename, dpi=100)
        plt.clf()
        plt.semilogx(self.delay, self.akf, " bo", markersize=2,
                     label="Autocorrelation data")
        popt, pcov = self.curveFit()
        plt.semilogx(self.delay, self.fitfun(self.delay, *popt), '-r',
                     label="exp. fit")
        plt.legend()
        plt.xlabel(r"Delay Time " + chr(964) + " [ms]")
        plt.ylabel("Autocorrelation Function g2 - 1")
        plt.title(self.samplename + ", Angle " + str(self.angle) + "°")
        self.A = popt[0]
        self.gamma = popt[1]

        plt.savefig(filepath)
        plt.close()
        return

    def saveAKFln(self, imagepath, datarange):
        """
        Saves plot of log(g2(q,tau) - 1) (log(FAKF)) versus the delay time tau
        in a file, fitted with a linear fit. Only uses the data contained
        in the indices specified by datarange.

        Input:
            imagepath:
                string, full path, indicating where the image should be saved.
            datarange:
                tuple, containing start and end indices of the data.

        Output:
            Imagefile of log(g2 -1) over tau.
        """
        plt.figure(self.filename, dpi=100)
        plt.clf()
        start, end = datarange

        # setting up log(g2 - 1), g2 - 1 also called g1
        lgg1 = [math.log(self.akf[n]) for n in range(start, end)]
        delay = self.delay[start:end]

        plt.plot(delay, lgg1, " bo", label="log(g2 - 1) data", markersize=2)

        def fitfun2(x, a, b): return a + (-2*b*x)
        popt, pcov = sco.curve_fit(fitfun2, delay, lgg1)
        plt.plot(delay, fitfun2(delay, *popt), '-r', label="linear fit")
        plt.legend()
        plt.xlabel("Delay Time " + chr(964) + " [ms]")
        plt.ylabel("log(g2(q," + chr(964) + ") - 1)")
        plt.title(self.samplename + ", Angle " + str(self.angle) + "°")
        self.A = popt[0]
        self.gamma = popt[1]

        plt.savefig(imagepath)
        plt.close()
        return

    def createDir(self):
        """
        Creates a directory for the current unique sample, if the directory
        doesnt already exist.

        returns: path of the directory
        """
        targetPath = os.getcwd() + "\\" + self.samplename
        if not os.path.exists(targetPath):
            os.makedirs(targetPath)
            return targetPath
        else:
            return targetPath


def linfun(x, a):
    """
    Simple linear function.
    """
    return a*x


def fitlin(xdata, ydata):
    """
    Fits linfun to data.
    """
    popt, pcov = sco.curve_fit(linfun, xdata, ydata)
    return popt, pcov


def getALVFiles(path=os.getcwd(), searchString="_averaged.ASC"):
    """
    Prints out a list of all filenames from the "_averaged.ASC" files that
    are in the current working directory.
    """
    fileList = os.listdir(path)
    ALVList = []
    for name in fileList:
        if name.endswith(searchString):
            ALVList.append(name)
    return ALVList


def getALVFilesReg(regex, path=os.getcwd()):
    """
    Prints out a list of all filenames in a path that match the given regexp &
    are in the specified path.

    Works the same as getALVFiles, but uses identifier from start.

    Input:
        regex: string of regular expression.
        path: full path to folder, default: current directory

    Output:
        List of filenames that match the regex.
    """
    fileList = os.listdir(path)
    ALVList = []
    regex = re.compile(regex)
    for name in fileList:
        matchobj = regex.match(name)
        if matchobj is not None:
            ALVList.append(name)
    return ALVList


def runtest():
    z = ALVData("LB6000018_averaged.asc")
    z.saveAKF("C://Users//Alex//Desktop//Test.png")
    print(z.q, z.gamma, z.wavelength)
    z.createDir()
    return


def createALVObjs(regex=r".*averaged\.ASC", path=os.getcwd()):
    """
    Extracts filenames from current working directory and returns a list
    with ALVObjects.

    returns: List of ALVData object extracted from the filenames in the dir.
    """
    fileList = getALVFilesReg(regex)
    objList = []
    for file in fileList:
        objList.append(ALVData(file))
    return objList


def getHydroDynR(diff, visc, temp):
    """
    Calculates hydrodynamic radius from inputs, all in SI units.

    diff: Diffusion coefficient
    visc: dynamic viscosity of solvent
    temp: Temperature of surroundings.
    """
    rhyd = KB * temp / (6 * np.pi * visc * diff)
    return rhyd


def fajunProcess():
    """
    Takes list of ALV objects, saves their autocorrelation figures + plot in
    the corresponding directory. Saves fitting parameters in a .txt file.
    """

    objList = createALVObjs()

    input("Enter drücken um fortzufahren.")
    print("Lade Dateien...")

    # deletes fit textfile should it already exist.
    for ALV in objList:
        path = ALV.createDir()
        txpath = path + "\\" + ALV.samplename + "Fit.txt"
        if os.path.isfile(txpath):
            os.remove(txpath)

    for ALV in objList:
        # Saves images to folders
        print(ALV)
        path = ALV.createDir()
        impath = path + "\\" + ALV.samplename + str(int(ALV.angle))\
            + "Grad.png"
        ALV.saveAKF(impath)

        # saves fit parameters to textfile.
        txpath = path + "\\" + ALV.samplename + "Fit.txt"
        if not os.path.isfile(txpath):
            with open(txpath, "w+") as txfile:
                txfile.write("Angle\t\tq^2\t\t\tA\t\tGamma [1/s]\t\t\n")

        with open(txpath, "a") as txfile:
            txfile.write(str(ALV.angle) + "\t\t" + "%.4E" % ALV.q**2 + "\t\t"
                         + "%.4f" % ALV.A + "\t\t"
                         + "%.4f" % ALV.gamma + "\t\t\n")

    # plottet Gamma gegen q^2, gewinnt daraus Diffusionskoeffizient
    namediff = None
    for ALV in objList:
        if namediff is None or not namediff == ALV.samplename:
            qList = []
            gammaList = []
            namediff = ALV.samplename
            txpath = ALV.createDir() + "\\" + ALV.samplename + "Fit.txt"
            with open(txpath, "r") as txfile:
                next(txfile)
                for line in txfile:
                    line = line.split("\t\t")
                    qList.append(float(line[1]))
                    gammaList.append(float(line[3]))

            # Muss aus irgendwelchen Gründen ein numpy array sein
            # plottet
            plt.figure(ALV.samplename, dpi=100)
            plt.clf()
            qList = np.array(qList)
            gammaList = np.array(gammaList)
            plt.plot(qList, gammaList, ' ko', markersize=2, label="Gamma")
            popt, pcov = fitlin(qList, gammaList)
            diffcoff = popt[0]
            plt.plot(qList, linfun(qList, *popt), '-r',
                     label="Lin. Gamma Fit, a = " + "%.2E" % diffcoff)
            plt.legend()
            plt.xlabel("q^2 [m^-2]")
            plt.ylabel(r"$\Gamma$ [1/s]")
            plt.title(ALV.samplename + ", Gamma over q^2")
            plt.savefig(ALV.createDir() + "\\" + ALV.samplename
                        + "GammaFit.png")
            plt.close()

            hydr = getHydroDynR(diffcoff, ALV.visc, ALV.temp)

            with open(txpath, "a") as tx:
                tx.write("\nDiffusion coefficient: " + str(diffcoff))
                tx.write("\nHydrodynamic Radius [m]: " + str(hydr))

    input("Erfolgreich abgeschlossen."
          "Enter drücken um das Programm zu beenden.")
    return


def schoepeProcess(regString=r"DLS.*\.txt", samplereg="_", path=os.getcwd(),
                   fallOffFunction=(lambda x: 0.8*x), channelStart=12):
    """
    Takes in a path. Creates ALV Objects from the ALV files contained in the
    path. Reduces Data contained in the samples, start with the value given in
    channelStart and ending after the initial value has fallen under a certain
    point specified by the fallOffFunction in dependence of the initial value.

    The log of the correlation function then gets plotted over the delay time
    (ln (g^2(q,tau) -1) again tau) and fitted in a linear function.

    The intercept that is obtained in the linear function for every ALVObject
    is then plotted against the scattering angle q.

    Input:
        samplereg: regular expression that assigns sample name by splitting
        at the pattern given.

        regString: Regular expression as string, gets compiled to reexp object
        and passed in into getALVFiles to find files that match the regexp.

        path: string, full path to operating system

        fallOffFunction: function that takes at the starting value (at index
        channelStart), operates on it and determines the value where the cut-
        off (last value that is used in the fitting later) value lies.

        channelStart: int, determine the index of the first element that should
        be taken into consideration at data evaluation.

    Output:
        Plots of data, relevant coefficients in .txt files.
    """
    objList = createALVObjs(regString)

    # deletes fit textfile should it already exist.
    for ALV in objList:
        ALV.samplename = re.split(samplereg, ALV.filename)[0]

        path = ALV.createDir()
        txpath = path + "\\" + ALV.samplename + "Fit.txt"
        if os.path.isfile(txpath):
            os.remove(txpath)

    for ALV in objList:

        # konfuse Methode um den Endpunkt herauszufinden
        end = [k for k in range(1, len(ALV.akf)) if ALV.akf[k]
               < fallOffFunction(ALV.akf[channelStart])][0]
        datarange = (channelStart, end)
        print(datarange)

        # Saves images to folders
        print(ALV)
        path = ALV.createDir()
        impath = path + "\\" + ALV.samplename + str(int(ALV.angle)) \
            + "Grad.png"
        ALV.saveAKFln(impath, datarange)

        # saves fit parameters to textfile.
        txpath = path + "\\" + ALV.samplename + "Fit.txt"
        if not os.path.isfile(txpath):
            with open(txpath, "w+") as txfile:
                txfile.write(
                     "Angle\t\tq^2\t\t\t\tA\t\tGamma [1/s]\t\tMeanCR0 \t\t\n")

        with open(txpath, "a") as txfile:
            txfile.write(str(ALV.angle) + "\t\t" + "%.4E" % ALV.q**2 + "\t\t"
                         + "%.4f" % ALV.A + "\t\t"
                         + "%.4f" % ALV.gamma + "\t\t"
                         + "%.4f" % ALV.countrate + "\t\t\n")

    # plottet Gamma gegen q^2, gewinnt daraus Diffusionskoeffizient
    namediff = None
    for ALV in objList:
        if namediff is None or not namediff == ALV.samplename:
            qList = []
            gammaList = []
            aList = []
            angleList = []
            countList = []
            namediff = ALV.samplename
            txpath = ALV.createDir() + "\\" + ALV.samplename + "Fit.txt"
            with open(txpath, "r") as txfile:
                next(txfile)
                for line in txfile:
                    line = line.split("\t\t")
                    qList.append(float(line[1]))
                    gammaList.append(float(line[3]))
                    angleList.append(float(line[0]))
                    aList.append(float(line[2]))
                    countList.append(float(line[4]))

            # Muss aus irgendwelchen Gründen ein numpy array sein
            # plottet gamma, mit von gamma
            plt.figure(ALV.samplename, dpi=100)
            plt.clf()
            qList = np.array(qList)
            gammaList = np.array(gammaList)
            plt.plot(qList, gammaList, ' ko', markersize=2, label="Gamma")
            popt, pcov = fitlin(qList, gammaList)
            diffcoff = popt[0]
            plt.plot(qList, linfun(qList, *popt), '-r',
                     label="Lin. Gamma Fit, a = " + "%.2E" % diffcoff)
            plt.legend()
            plt.xlabel("q^2 [m^-2]")
            plt.ylabel(r"$\Gamma$ [1/s]")
            plt.title(ALV.samplename + ", Gamma over q^2")
            plt.savefig(
                ALV.createDir() + "\\" + ALV.samplename + "GammaFit.png")
            plt.close()

            # plots intercept over angle
            plt.figure(ALV.samplename, dpi=100)
            plt.clf()
            plt.plot(
                angleList, aList, ' bo', markersize=2, label="y-Intercept")
            plt.legend()
            plt.title(ALV.samplename + ", y-Intercept over angle")
            plt.xlabel(r"$\theta$ in °")
            plt.ylabel("y-intercept (logarithmical, from fit)")
            plt.savefig(
                ALV.createDir() + "\\" + ALV.samplename + "y-intercept.png")
            plt.close()

            # plots Mean Countrate over angle
            plt.figure(ALV.samplename, dpi=100)
            plt.clf()
            plt.plot(angleList, countList, ' bo', markersize=2, label="meanCR")
            plt.legend()
            plt.title(ALV.samplename + ", meanCR over angle")
            plt.xlabel(r"$\theta$ in °")
            plt.ylabel("Mean Countrate")
            plt.savefig(ALV.createDir() + "\\" + ALV.samplename + "meanCR.png")
            plt.close()

            hydr = getHydroDynR(diffcoff, ALV.visc, ALV.temp)

            with open(txpath, "a") as tx:
                tx.write("\nDiffusion coefficient: " + str(diffcoff))
                tx.write("\nHydrodynamic Radius [m]: " + str(hydr))

    input("Erfolgreich abgeschlossen."
          "Enter drücken um das Programm zu beenden.")
    return


schoepeProcess()
